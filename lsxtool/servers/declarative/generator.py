"""
Generador de archivos .conf desde estado declarativo
Convierte YAML → .conf. Los .conf son GENERATED BY LSXTOOL; la fuente de verdad es el estado declarativo.
"""

from pathlib import Path
from typing import Optional
from rich.console import Console

from .models import DomainConfig, ServerWebType
from .loader import DeclarativeLoader
from .upstream_loader import UpstreamCatalogLoader
from .upstream_catalog import UpstreamCatalogDef


GENERATED_BANNER = "# GENERATED BY LSXTOOL — No editar manualmente; regenerar desde estado declarativo.\n"


class ConfigGenerator:
    """Genera archivos .conf desde configuración declarativa"""

    def __init__(self, base_dir: Path, console: Optional[Console] = None):
        self.base_dir = base_dir
        self.console = console or Console()
        self.loader = DeclarativeLoader(base_dir, console)
        self.upstream_loader = UpstreamCatalogLoader(base_dir, console)

    def generate_nginx_config(self, domain_config: DomainConfig) -> Optional[str]:
        """
        Genera contenido de .conf para Nginx desde DomainConfig.
        Si server_web.upstream_ref está definido, usa el catálogo de upstreams; si no, usa server_web.upstream inline.
        """
        sw = domain_config.server_web
        backend_type = getattr(sw.type, 'value', sw.type) if sw and sw.type else None
        if backend_type != "nginx" and backend_type != ServerWebType.NGINX:
            return None

        lines = [GENERATED_BANNER.strip(), ""]

        # Bloque META
        lines.append("# --- LSX META ---")
        server_web_type_str = getattr(sw.type, 'value', sw.type) if sw and sw.type else "nginx"
        server_web_version = (sw.version if sw and sw.version else None) or self._get_nginx_version()
        lines.append(f"# server_web: {server_web_type_str}")
        lines.append(f"# server_web_version: {server_web_version}")
        env_value = getattr(domain_config.environment, 'value', None) or str(domain_config.environment) if domain_config.environment else "dev"
        lines.append(f"# environment: {env_value}")
        if domain_config.owner:
            lines.append(f"# owner: {domain_config.owner}")
        lines.append(f"# provider: {domain_config.provider}")

        upstream_ref = getattr(sw, "upstream_ref", None) or None
        provider = getattr(domain_config, "provider", None) or ""
        server = server_web_type_str.lower() if server_web_type_str else "nginx"
        env = env_value
        if upstream_ref:
            # META: solo tech y tech_version (no upstream_ref ni tech_port aquí).
            if sw.upstream:
                up = sw.upstream
                service_type_val = getattr(up.service_type, 'value', up.service_type) if up.service_type else "api"
                lines.append(f"# service_type: {service_type_val}")
                tech_val = getattr(up.tech, 'value', up.tech) if up.tech else "node"
                lines.append(f"# tech: {tech_val}")
                lines.append(f"# tech_version: {up.tech_version}")
            else:
                lines.append("# service_type: api")
        elif sw.upstream:
            up = sw.upstream
            service_type_val = getattr(up.service_type, 'value', up.service_type) if up.service_type else "api"
            lines.append(f"# service_type: {service_type_val}")
            tech_val = getattr(up.tech, 'value', up.tech) if up.tech else "node"
            lines.append(f"# tech: {tech_val}")
            lines.append(f"# tech_version: {up.tech_version}")
        else:
            lines.append("# service_type: web")

        lines.append("# --- END META ---")
        lines.append("")

        # Upstream: desde catálogo (convención o legacy) o inline
        upstream_name = ""
        if upstream_ref:
            catalog_def = self.upstream_loader.load(upstream_ref, provider=provider, server=server, environment=env)
            if catalog_def:
                upstream_name = catalog_def.name
                lines.extend(self._nginx_upstream_block(catalog_def))
                lines.append("")
        elif sw.upstream:
            upstream_name = self._generate_upstream_name(domain_config)
            up = sw.upstream
            lines.append(f"upstream {upstream_name} {{")
            lines.append(f"    server 127.0.0.1:{up.port};")
            lines.append("}")
            lines.append("")

        # Server block: root siempre declarado (ownership y permisos), aunque sea solo proxy
        root_path = (sw.root if sw else None) or f"/var/www/{domain_config.provider.lower()}/{env_value}/{domain_config.slug}"
        log_path = f"/var/log/{domain_config.provider.lower()}/{env_value}/{domain_config.slug}"

        listen_port = (sw.listen_port if sw else None) or 9100
        lines.append("server {")
        lines.append(f"    listen {listen_port};")
        lines.append(f"    listen [::]:{listen_port};")
        lines.append(f"    server_name {domain_config.domain};")
        lines.append("")
        lines.append("    # Root declarado para ownership y permisos")
        if upstream_name:
            lines.append("    # No se utiliza contenido estático en este servicio")
        lines.append(f"    root {root_path};")
        lines.append("")
        lines.append(f"    access_log {log_path}/access.log;")
        lines.append(f"    error_log {log_path}/error.log;")
        lines.append("")

        lines.append("    location / {")
        if upstream_name:
            lines.append(f"        proxy_pass http://{upstream_name};")
            lines.append("        proxy_http_version 1.1;")
            lines.append("        proxy_set_header Host $host;")
            lines.append("        proxy_set_header X-Real-IP $remote_addr;")
            lines.append("        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;")
            lines.append("        proxy_set_header X-Forwarded-Proto $scheme;")
        else:
            lines.append("        index index.html index.htm;")
        lines.append("    }")
        lines.append("}")

        return "\n".join(lines)

    def _nginx_upstream_block(self, defn: UpstreamCatalogDef) -> list:
        """Genera líneas nginx para un upstream del catálogo (con weights si aplica)."""
        lines = [f"upstream {defn.name} {{"]
        for s in defn.servers:
            part = f"    server {s.host}:{s.port}"
            if s.weight is not None:
                part += f" weight={s.weight}"
            if s.role and s.role == "backup":
                part += " backup"
            part += ";"
            lines.append(part)
        lines.append("}")
        return lines

    def _generate_upstream_name(self, domain_config: DomainConfig) -> str:
        """Genera nombre de upstream en formato snake_case (solo para upstream inline)."""
        if not domain_config.server_web or not domain_config.server_web.upstream:
            return ""
        upstream = domain_config.server_web.upstream
        domain_slug = domain_config.domain.replace(".", "_").replace("-", "_")
        parts = domain_slug.split("_")
        if len(parts) >= 2:
            domain_slug = "_".join(parts[:2])
        service_type_val = getattr(upstream.service_type, 'value', upstream.service_type) if upstream.service_type else "api"
        env_val = getattr(domain_config.environment, 'value', None) or str(domain_config.environment) if domain_config.environment else "dev"
        return f"{service_type_val}_{env_val}_{domain_slug}"
    
    def _get_nginx_version(self) -> str:
        """Obtiene versión de Nginx instalada"""
        try:
            from ..sites.server_version import get_nginx_version
            version = get_nginx_version()
            return version or "1.26.3"
        except:
            return "1.26.3"
    
    def write_config(self, domain_config: DomainConfig) -> Optional[Path]:
        """
        Escribe archivo .conf para un dominio
        
        Returns:
            Path al archivo escrito o None si hay error
        """
        content = self.generate_nginx_config(domain_config)
        if not content:
            return None
        
        # Determinar ruta del .conf
        provider_lower = domain_config.provider.lower()
        env = getattr(domain_config.environment, 'value', None) or str(domain_config.environment) if domain_config.environment else "dev"
        conf_dir = (
            self.base_dir / "lsxtool" / "servers" / "nginx" / "configuration" /
            "etc" / "nginx" / "conf.d" / provider_lower / env
        )
        conf_dir.mkdir(parents=True, exist_ok=True)
        
        conf_file = conf_dir / f"{domain_config.domain}.conf"
        
        try:
            conf_file.write_text(content)
            if self.console:
                self.console.print(f"[green]✅ Config generado: {conf_file}[/green]")
            return conf_file
        except Exception as e:
            if self.console:
                self.console.print(f"[red]❌ Error al escribir config: {e}[/red]")
            return None
