"""
Generador v2 de NGINX desde estado declarativo (frontends + upstreams v2).
Reglas: upstreams primero, server después, proxy_pass siempre al upstream, nunca IPs en location.
Soporta: routes como lista con name, upstreams multi-node para canary/weighted.
"""

from pathlib import Path
from typing import Optional, List, Dict, Any, Union

from rich.console import Console

from .models_v2 import (
    FrontendDomainConfig,
    RouteConfig,
    UpstreamDefConfig,
    UpstreamNodeConfig,
    UriTransformConfig,
    migrate_dict_routes_to_list,
)
from .loader_v2 import load_upstream_v2

GENERATED_BANNER = "# GENERATED BY LSXTOOL — No editar manualmente; regenerar desde estado declarativo.\n"


def _slug_from_domain(domain: str) -> str:
    d = domain.replace("dev-", "").replace("qa-", "").replace("prod-", "")
    return d.split(".")[0]


def _ref_to_bucket_var(ref: str) -> str:
    """api__demo -> api_demo_bucket (variable NGINX)."""
    return ref.replace("__", "_") + "_bucket"


def _is_canary_split(up: UpstreamDefConfig) -> bool:
    """True si upstream usa canary con nodos base/canary (split_clients style)."""
    if not up.routing or up.routing.strategy != "canary" or not up.routing.canary:
        return False
    nodes = up.get_effective_nodes()
    base = [n for n in nodes if getattr(n, "group", None) == "base"]
    canary = [n for n in nodes if getattr(n, "group", None) == "canary"]
    return bool(base) and bool(canary)


def _stickiness_split_key(canary_cfg: Any) -> str:
    """Variable NGINX para split_clients según stickiness. Retorna request_id, remote_addr, etc."""
    stickiness = getattr(canary_cfg, "stickiness", None)
    if stickiness == "ip":
        return "remote_addr"
    return "request_id"  # none, request


def _nginx_split_clients(ref: str, canary_cfg: Any, var_suffix: str = "") -> List[str]:
    """
    split_clients. var_suffix: "" para bucket final, "_sc" para variable intermedia (cookie).
    """
    cw = getattr(canary_cfg, "canary_weight", 10)
    split_key = _stickiness_split_key(canary_cfg)
    var = _ref_to_bucket_var(ref) + var_suffix
    return [
        f"# --- Canary split: {ref} ---",
        f'split_clients "${split_key}" ${var} {{',
        f"    {cw}%     canary;",
        f"    *       base;",
        "}",
        "",
    ]


def _nginx_map_canary(ref: str, canary_cfg: Any, mode: str) -> List[str]:
    """map para stickiness=header o cookie. Para cookie usa split_clients como default."""
    var = _ref_to_bucket_var(ref)
    if mode == "header":
        key = getattr(canary_cfg, "sticky_key", None) or getattr(canary_cfg, "header", None) or "X-Canary"
        key_nginx = key.lower().replace("-", "_")
        return [
            f"# --- Canary map (header): {ref} ---",
            f'map $http_{key_nginx} ${var} {{',
            '    default base;',
            '    "true" canary;',
            '    "1" canary;',
            "}",
            "",
        ]
    # cookie: map usa split_clients como default (primera visita)
    key = getattr(canary_cfg, "sticky_key", None) or getattr(canary_cfg, "cookie", None) or "lsx_canary"
    key_nginx = key.lower().replace("-", "_")
    sc_var = var + "_sc"
    lines = _nginx_split_clients(ref, canary_cfg, "_sc")
    lines.extend([
        f"# --- Canary map (cookie): {ref} ---",
        f'map $cookie_{key_nginx} ${var} {{',
        f'    default ${sc_var};',
        '    "base" base;',
        '    "canary" canary;',
        "}",
        "",
    ])
    return lines


def _nginx_upstream_block_multinode(
    name: str,
    nodes: List[UpstreamNodeConfig],
    use_weights: bool = True,
) -> List[str]:
    """
    Genera bloque upstream. use_weights: si False (base con 1 nodo), sin weight.
    """
    lines = [f"upstream {name} {{"]
    for node in nodes:
        parts = [f"    server {node.runtime.host}:{node.runtime.port}"]
        if use_weights and node.weight is not None and (node.weight != 100 or len(nodes) > 1):
            parts.append(f" weight={node.weight}")
        if node.backup:
            parts.append(" backup")
        if node.down:
            parts.append(" down")
        lines.append("".join(parts) + ";")
    lines.append("}")
    return lines


def _nginx_upstream_block_simple(name: str, host: str, port: int) -> List[str]:
    """Genera bloque upstream para un solo server (retrocompat)."""
    return [f"upstream {name} {{", f"    server {host}:{port};", "}"]


def _get_routes_list(domain_config: FrontendDomainConfig) -> List[RouteConfig]:
    """
    Obtiene routes como lista. Soporta:
    - Lista (nuevo formato)
    - Dict (formato antiguo, se convierte a lista)
    """
    routes = domain_config.routes
    if routes is None:
        return []
    
    # Si es lista, usar directamente
    if isinstance(routes, list):
        return routes
    
    # Si es dict, migrar a lista
    if isinstance(routes, dict):
        return migrate_dict_routes_to_list(routes)
    
    return []


def generate_nginx_config_v2(
    base_dir: Path,
    domain_config: FrontendDomainConfig,
    provider_id: str,
    env: str,
    console: Optional[Console] = None,
) -> Optional[str]:
    """
    Genera .conf para un frontend.
    Upstreams primero (desde upstreams v2 con soporte multi-node), luego server con locations por routes.
    """
    console = console or Console()
    sw = domain_config.server_web
    st = getattr(sw.type, "value", sw.type) if hasattr(sw, "type") else sw.type
    if str(st).lower() != "nginx":
        return None

    lines = [GENERATED_BANNER.strip(), ""]

    # --- META (reducido) ---
    lines.append("# --- LSX META ---")
    lines.append("# server_web: nginx")
    lines.append(f"# server_web_version: {sw.version or '1.26.3'}")
    lines.append(f"# environment: {domain_config.environment}")
    lines.append(f"# provider: {domain_config.provider}")
    lines.append("# role: frontend")
    if domain_config.root:
        lines.append(f"# root.path: {domain_config.root.path}")
        lines.append(f"# owner: {domain_config.root.owner}")
        lines.append(f"# technical_user: {domain_config.root.technical_user}")
    lines.append("# --- END META ---")
    lines.append("")

    # Obtener routes como lista
    routes_list = _get_routes_list(domain_config)

    # 1. Refs únicos y detectar canary
    refs = set()
    canary_refs = {}  # ref -> UpstreamDefConfig (para split_clients)
    for route in routes_list:
        ref = getattr(route, "upstream_ref", None) if not isinstance(route, dict) else route.get("upstream_ref")
        if ref:
            refs.add(ref)

    for ref in sorted(refs):
        up = load_upstream_v2(base_dir, ref, provider_id, env, console)
        if up and _is_canary_split(up):
            canary_refs[ref] = up

    # 2. split_clients / map (canary PRO) — antes de upstreams
    for ref, up in sorted(canary_refs.items()):
        canary_cfg = up.routing.canary
        stickiness = getattr(canary_cfg, "stickiness", None)
        mode = getattr(canary_cfg, "mode", "percentage") or "percentage"
        # Prefer stickiness; si no hay, derivar de mode (retrocompat)
        effective = stickiness or {"percentage": "none", "header": "header", "cookie": "cookie"}.get(mode, "none")
        if effective in ("none", "request", "ip"):
            lines.extend(_nginx_split_clients(ref, canary_cfg))
        elif effective == "header":
            lines.extend(_nginx_map_canary(ref, canary_cfg, "header"))
        elif effective == "cookie":
            lines.extend(_nginx_map_canary(ref, canary_cfg, "cookie"))

    # 3. Upstreams
    for ref in sorted(refs):
        up = load_upstream_v2(base_dir, ref, provider_id, env, console)
        if not up:
            continue
        nodes = up.get_effective_nodes()
        if not nodes:
            continue

        if ref in canary_refs:
            # Canary PRO: dos upstreams separados (_base, _canary)
            base_nodes = [n for n in nodes if getattr(n, "group", None) == "base"]
            canary_nodes = [n for n in nodes if getattr(n, "group", None) == "canary"]
            # Base: sin weights si 1 nodo
            block_base = _nginx_upstream_block_multinode(
                f"{ref}_base", base_nodes, use_weights=(len(base_nodes) > 1)
            )
            # Canary: weights relativos dentro del grupo
            block_canary = _nginx_upstream_block_multinode(
                f"{ref}_canary", canary_nodes, use_weights=True
            )
            lines.extend(block_base)
            lines.append("")
            lines.extend(block_canary)
        elif len(nodes) == 1:
            block = _nginx_upstream_block_simple(ref, nodes[0].runtime.host, nodes[0].runtime.port)
            lines.extend(block)
        else:
            # Multi-node simple (weighted rollout, no canary split)
            block = _nginx_upstream_block_multinode(ref, nodes, use_weights=True)
            lines.extend(block)

        lines.append("")

    # 2. Server block
    slug = _slug_from_domain(domain_config.domain)
    provider_lower = (domain_config.provider or "").lower()
    env_val = domain_config.environment or "dev"
    root_path = (domain_config.root.path if domain_config.root else None) or f"/var/www/{provider_lower}/{env_val}/{slug}"
    log_path = f"/var/log/{provider_lower}/{env_val}/{slug}"
    listen_port = 9100

    lines.append("server {")
    lines.append(f"    listen {listen_port};")
    lines.append(f"    listen [::]:{listen_port};")
    lines.append(f"    server_name {domain_config.domain};")
    lines.append("")
    lines.append("    # Root declarado para ownership y permisos")
    if refs:
        lines.append("    # No se utiliza contenido estático en este servicio")
        lines.append(f"    # root {root_path};")
    else:
        lines.append(f"    root {root_path};")
    lines.append("")
    lines.append(f"    access_log {log_path}/access.log;")
    lines.append(f"    error_log {log_path}/error.log;")
    lines.append("")

    # Locations desde routes; más específicas primero (nginx longest prefix)
    # Ordenar por public path (más largo primero)
    def get_public_path(route) -> str:
        if isinstance(route, dict):
            uri = route.get("uri", {})
            return uri.get("public", "/") if isinstance(uri, dict) else getattr(uri, "public", "/")
        uri = getattr(route, "uri", None)
        if uri:
            return getattr(uri, "public", "/")
        return "/"
    
    sorted_routes = sorted(routes_list, key=lambda r: (-len(get_public_path(r)), get_public_path(r)))
    
    for route in sorted_routes:
        # Extraer datos de la route (soportar dict y objeto)
        if isinstance(route, dict):
            upstream_ref = route.get("upstream_ref")
            uri_cfg = route.get("uri", {})
            route_name = route.get("name", "unnamed")
        else:
            upstream_ref = getattr(route, "upstream_ref", None)
            uri_cfg = getattr(route, "uri", None)
            route_name = getattr(route, "name", "unnamed")
        
        if not upstream_ref:
            continue
        
        # Extraer uri config
        if uri_cfg:
            if isinstance(uri_cfg, dict):
                public = uri_cfg.get("public", "/")
                upstream_path = uri_cfg.get("upstream", "/")
                strategy = uri_cfg.get("strategy", "strip")
            else:
                public = getattr(uri_cfg, "public", "/")
                upstream_path = getattr(uri_cfg, "upstream", "/")
                strategy = getattr(uri_cfg, "strategy", "strip")
        else:
            # Inferir default
            public = "/"
            upstream_path = "/"
            strategy = "passthrough"
        
        # Normalizar public (location en nginx)
        loc = public if public == "/" or public.endswith("/") else public + "/"
        
        # Comentario con nombre de la route
        lines.append(f"    # Route: {route_name}")
        lines.append(f"    location {loc} {{")
        
        # Canary: proxy_pass a upstream dinámico según bucket
        is_canary = upstream_ref in canary_refs
        if is_canary:
            bucket_var = _ref_to_bucket_var(upstream_ref)
            upstream_target = f"{upstream_ref}_${bucket_var}"
        else:
            upstream_target = upstream_ref

        # Generar rewrite o proxy_pass según strategy
        if strategy == "strip":
            public_regex = loc.rstrip("/").replace("/", r"\/")
            upstream_clean = upstream_path.rstrip("/")
            lines.append(f"        rewrite ^{public_regex}/?(.*)$ {upstream_clean}/$1 break;")
            lines.append(f"        proxy_pass http://{upstream_target};")
        else:
            upstream_clean = upstream_path if upstream_path.endswith("/") else upstream_path + "/"
            lines.append(f"        proxy_pass http://{upstream_target}{upstream_clean};")

        lines.append("        proxy_http_version 1.1;")
        lines.append("        proxy_set_header Host $host;")
        lines.append("        proxy_set_header X-Real-IP $remote_addr;")
        lines.append("        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;")
        lines.append("        proxy_set_header X-Forwarded-Proto $scheme;")
        if is_canary:
            bucket_var = _ref_to_bucket_var(upstream_ref)
            lines.append(f"        proxy_set_header X-LSX-Canary ${bucket_var};")
            up = canary_refs.get(upstream_ref)
            if up and up.routing and up.routing.canary:
                stickiness = getattr(up.routing.canary, "stickiness", None)
                if stickiness == "cookie":
                    key = getattr(up.routing.canary, "sticky_key", None) or getattr(up.routing.canary, "cookie", None) or "lsx_canary"
                    lines.append(f"        add_header Set-Cookie \"{key}=${bucket_var}; Path=/; Max-Age=86400\" always;")
        lines.append("    }")
        lines.append("")

    lines.append("}")

    return "\n".join(lines)


def write_config_v2(
    base_dir: Path,
    domain_config: FrontendDomainConfig,
    provider_id: str,
    env: str,
    out_dir: Optional[Path] = None,
    console: Optional[Console] = None,
) -> Optional[Path]:
    """Escribe .conf para el frontend. out_dir por defecto: lsxtool/.../configuration/etc/nginx/conf.d/<provider>/<env>/."""
    content = generate_nginx_config_v2(base_dir, domain_config, provider_id, env, console)
    if not content:
        return None

    if out_dir is None:
        provider_lower = (domain_config.provider or "").lower()
        env_val = domain_config.environment or "dev"
        out_dir = (
            base_dir / "lsxtool" / "servers" / "nginx" / "configuration"
            / "etc" / "nginx" / "conf.d" / provider_lower / env_val
        )
    out_dir.mkdir(parents=True, exist_ok=True)
    conf_file = out_dir / f"{domain_config.domain}.conf"

    try:
        conf_file.write_text(content)
        if console:
            console.print(f"[green]✅ Config generado: {conf_file}[/green]")
        return conf_file
    except Exception as e:
        if console:
            console.print(f"[red]❌ Error al escribir config: {e}[/red]")
        return None
